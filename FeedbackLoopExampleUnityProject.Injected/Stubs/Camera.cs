using System;

/// <summary>
/// This file is provided so that unity engine classes can be swapped out
/// during running in a reloadable context, enabling runninf of game code
/// outside of the unity engine. The classes are generated by using the
/// 'Go to Definition' in VS, and copying out the definition into this file.
/// All methods and getters and then set to return <see cref="NotImplementedException"/>,
/// and only methods used by the scenario are made to work (such as Input,
/// and Scene Traversal mechanisms)
/// </summary>
namespace FL
{
    //
    // Summary:
    //     A Camera is a device through which the player views the world.
    //[NativeHeader("Runtime/Graphics/RenderTexture.h")]
    //[NativeHeader("Runtime/Shaders/Shader.h")]
    //[NativeHeader("Runtime/GfxDevice/GfxDeviceTypes.h")]
    //[NativeHeader("Runtime/Camera/RenderManager.h")]
    //[NativeHeader("Runtime/Camera/Camera.h")]
    //[NativeHeader("Runtime/Graphics/CommandBuffer/RenderingCommandBuffer.h")]
    //[NativeHeader("Runtime/Misc/GameObjectUtility.h")]
    //[RequireComponent(typeof(Transform))]
    //[UsedByNativeCode]
    public partial class Camera : Behaviour
    {
        //
        // Summary:
        //     Event that is fired before any camera starts culling.
        public static UnityEngine.Camera.CameraCallback onPreCull;
        //
        // Summary:
        //     Event that is fired before any camera starts rendering.
        public static UnityEngine.Camera.CameraCallback onPreRender;
        //
        // Summary:
        //     Event that is fired after any camera finishes rendering.
        public static UnityEngine.Camera.CameraCallback onPostRender;

        public Camera() { }

        //
        // Summary:
        //     The number of cameras in the current Scene.
        public static int allCamerasCount => throw new NotImplementedException();
        //
        // Summary:
        //     Returns all enabled cameras in the Scene.
        public static Camera[] allCameras => throw new NotImplementedException();

        //
        // Summary:
        //     The camera we are currently rendering with, for low-level render control only
        //     (Read Only).
        public static Camera current => throw new NotImplementedException();
        //
        // Summary:
        //     Should the camera clear the stencil buffer after the deferred light pass?
        public bool clearStencilAfterLightingPass { get; set; }
        //
        // Summary:
        //     Enable [UsePhysicalProperties] to use physical camera properties to compute the
        //     field of view and the frustum.
        public bool usePhysicalProperties { get; set; }
        //
        // Summary:
        //     The UnityEngine.Color with which the screen will be cleared.
        public UnityEngine.Color backgroundColor { get; set; }
        //
        // Summary:
        //     The size of the camera sensor, expressed in millimeters.
        public UnityEngine.Vector2 sensorSize { get; set; }
        //
        // Summary:
        //     The lens offset of the camera. The lens shift is relative to the sensor size.
        //     For example, a lens shift of 0.5 offsets the sensor by half its horizontal size.
        public UnityEngine.Vector2 lensShift { get; set; }
        //
        // Summary:
        //     Sets a custom matrix for the camera to use for all culling queries.
        public UnityEngine.Matrix4x4 cullingMatrix { get; set; }
        //
        // Summary:
        //     Whether or not the Camera will use occlusion culling during rendering.
        public bool useOcclusionCulling { get; set; }
        //
        // Summary:
        //     Per-layer culling distances.
        public float[] layerCullDistances { get; set; }
        //
        // Summary:
        //     Identifies what kind of camera this is.
        public UnityEngine.CameraType cameraType { get; set; }
        //
        // Summary:
        //     How to perform per-layer culling for a Camera.
        public bool layerCullSpherical { get; set; }
        //
        // Summary:
        //     How and if camera generates a depth texture.
        public UnityEngine.DepthTextureMode depthTextureMode { get; set; }
        //
        // Summary:
        //     How the camera clears the background.
        public UnityEngine.CameraClearFlags clearFlags { get; set; }
        //
        // Summary:
        //     Get the world-space speed of the camera (Read Only).
        public UnityEngine.Vector3 velocity => throw new NotImplementedException();
        //
        // Summary:
        //     This is used to render parts of the Scene selectively.
        public int cullingMask { get; set; }
        //
        // Summary:
        //     The camera focal length, expressed in millimeters. To use this property, enable
        //     UsePhysicalProperties.
        public float focalLength { get; set; }
        //
        // Summary:
        //     The aspect ratio (width divided by height).
        public float aspect { get; set; }
        //
        // Summary:
        //     Camera's depth in the camera rendering order.
        public float depth { get; set; }
        //
        // Summary:
        //     An axis that describes the direction along which the distances of objects are
        //     measured for the purpose of sorting.
        public UnityEngine.Vector3 transparencySortAxis { get; set; }
        //
        // Summary:
        //     Transparent object sorting mode.
        public UnityEngine.TransparencySortMode transparencySortMode { get; set; }
        //
        // Summary:
        //     Opaque object sorting mode.
        public UnityEngine.Rendering.OpaqueSortMode opaqueSortMode { get; set; }
        //
        // Summary:
        //     Is the camera orthographic (true) or perspective (false)?
        public bool orthographic { get; set; }
        //
        // Summary:
        //     Camera's half-size when in orthographic mode.
        public float orthographicSize { get; set; }
        //
        // Summary:
        //     Should camera rendering be forced into a RenderTexture.
        //[NativeProperty("ForceIntoRT")]
        public bool forceIntoRenderTexture { get; set; }
        //
        // Summary:
        //     Dynamic Resolution Scaling.
        public bool allowDynamicResolution { get; set; }
        //
        // Summary:
        //     MSAA rendering.
        public bool allowMSAA { get; set; }
        //
        // Summary:
        //     High dynamic range rendering.
        public bool allowHDR { get; set; }
        //
        // Summary:
        //     Mask to select which layers can trigger events on the camera.
        public int eventMask { get; set; }
        //
        // Summary:
        //     There are two gates for a camera, the sensor gate and the resolution gate. The
        //     physical camera sensor gate is defined by the sensorSize property, the resolution
        //     gate is defined by the render target area.
        public UnityEngine.Camera.GateFitMode gateFit { get; set; }
        //
        // Summary:
        //     How wide is the camera in pixels (accounting for dynamic resolution scaling)
        //     (Read Only).
        public int scaledPixelWidth => throw new NotImplementedException();
        //
        // Summary:
        //     Where on the screen is the camera rendered in pixel coordinates.
        //[NativeProperty("ScreenViewportRect")]
        public UnityEngine.Rect pixelRect { get; set; }     
        //
        // Summary:
        //     Number of command buffers set up on this camera (Read Only).
        public int commandBufferCount => throw new NotImplementedException();
        //
        // Summary:
        //     Returns the eye that is currently rendering. If called when stereo is not enabled
        //     it will return Camera.MonoOrStereoscopicEye.Mono. If called during a camera rendering
        //     callback such as OnRenderImage it will return the currently rendering eye. If
        //     called outside of a rendering callback and stereo is enabled, it will return
        //     the default eye which is Camera.MonoOrStereoscopicEye.Left.
        public UnityEngine.Camera.MonoOrStereoscopicEye stereoActiveEye => throw new NotImplementedException();
        //
        // Summary:
        //     Defines which eye of a VR display the Camera renders into.
        public UnityEngine.StereoTargetEyeMask stereoTargetEye { get; set; }
        //
        // Summary:
        //     Determines whether the stereo view matrices are suitable to allow for a single
        //     pass cull.
        public bool areVRStereoViewMatricesWithinSingleCullTolerance => throw new NotImplementedException();
        //
        // Summary:
        //     Distance to a point where virtual eyes converge.
        public float stereoConvergence { get; set; }
        //
        // Summary:
        //     The distance between the virtual eyes. Use this to query or set the current eye
        //     separation. Note that most VR devices provide this value, in which case setting
        //     the value will have no effect.
        public float stereoSeparation { get; set; }
        //
        // Summary:
        //     Stereoscopic rendering.
        public bool stereoEnabled => throw new NotImplementedException();
        //
        // Summary:
        //     If not null, the camera will only render the contents of the specified Scene.
        public UnityEngine.SceneManagement.Scene scene { get; set; }
        //
        // Summary:
        //     Get the view projection matrix used on the last frame.
        public UnityEngine.Matrix4x4 previousViewProjectionMatrix => throw new NotImplementedException();
        //
        // Summary:
        //     Should the jittered matrix be used for transparency rendering?
        //[NativeProperty("UseJitteredProjectionMatrixForTransparent")]
        public bool useJitteredProjectionMatrixForTransparentRendering { get; set; }
        //
        // Summary:
        //     Get or set the raw projection matrix with no camera offset (no jittering).
        public UnityEngine.Matrix4x4 nonJitteredProjectionMatrix { get; set; }
        //
        // Summary:
        //     Set a custom projection matrix.
        public UnityEngine.Matrix4x4 projectionMatrix { get; set; }
        //
        // Summary:
        //     Matrix that transforms from world to camera space.
        public UnityEngine.Matrix4x4 worldToCameraMatrix { get; set; }
        //
        // Summary:
        //     Matrix that transforms from camera space to world space (Read Only).
        public UnityEngine.Matrix4x4 cameraToWorldMatrix => throw new NotImplementedException();
        //
        // Summary:
        //     Set the target display for this Camera.
        public int targetDisplay { get; set; }
        //
        // Summary:
        //     Gets the temporary RenderTexture target for this Camera.
        public UnityEngine.RenderTexture activeTexture => throw new NotImplementedException();
        //
        // Summary:
        //     Destination render texture.
        public UnityEngine.RenderTexture targetTexture { get; set; }
        //
        // Summary:
        //     How tall is the camera in pixels (accounting for dynamic resolution scaling)
        //     (Read Only).
        public int scaledPixelHeight => throw new NotImplementedException();
        //
        // Summary:
        //     The rendering path that is currently being used (Read Only).
        public UnityEngine.RenderingPath actualRenderingPath => throw new NotImplementedException();
        //
        // Summary:
        //     How tall is the camera in pixels (not accounting for dynamic resolution scaling)
        //     (Read Only).
        public int pixelHeight => throw new NotImplementedException();
        //
        // Summary:
        //     How wide is the camera in pixels (not accounting for dynamic resolution scaling)
        //     (Read Only).
        public int pixelWidth => throw new NotImplementedException();
        //
        // Summary:
        //     Where on the screen is the camera rendered in normalized coordinates.
        //[NativeProperty("NormalizedViewportRect")]
        public UnityEngine.Rect rect { get; set; }
        //
        // Summary:
        //     The rendering path that should be used, if possible.
        public UnityEngine.RenderingPath renderingPath { get; set; }
        //
        // Summary:
        //     The field of view of the camera in degrees.
        //[NativeProperty("Fov")]
        public float fieldOfView { get; set; }
        //
        // Summary:
        //     The far clipping plane distance.
        //[NativeProperty("Far")]
        public float farClipPlane { get; set; }
        //
        // Summary:
        //     The near clipping plane distance.
        //[NativeProperty("Near")]
        public float nearClipPlane { get; set; }

        public static void CalculateProjectionMatrixFromPhysicalProperties(out UnityEngine.Matrix4x4 output, float focalLength, UnityEngine.Vector2 sensorSize, UnityEngine.Vector2 lensShift, float nearClip, float farClip, UnityEngine.Camera.GateFitParameters gateFitParameters = default) => throw new NotImplementedException();
        //
        // Summary:
        //     Converts focal length to field of view.
        //
        // Parameters:
        //   focalLength:
        //     Focal length in millimeters.
        //
        //   sensorSize:
        //     Sensor size in millimeters. Use the sensor height to get the vertical field of
        //     view. Use the sensor width to get the horizontal field of view.
        //
        // Returns:
        //     field of view in degrees.
        public static float FocalLengthToFOV(float focalLength, float sensorSize) => throw new NotImplementedException();
        //
        // Summary:
        //     Converts field of view to focal length. Use either sensor height and vertical
        //     field of view or sensor width and horizontal field of view.
        //
        // Parameters:
        //   fov:
        //     field of view in degrees.
        //
        //   sensorSize:
        //     Sensor size in millimeters.
        //
        // Returns:
        //     Focal length in millimeters.
        public static float FOVToFocalLength(float fov, float sensorSize) => throw new NotImplementedException();
        //
        // Summary:
        //     Fills an array of Camera with the current cameras in the Scene, without allocating
        //     a new array.
        //
        // Parameters:
        //   cameras:
        //     An array to be filled up with cameras currently in the Scene.
        public static int GetAllCameras(Camera[] cameras) => throw new NotImplementedException();
        //[FreeFunction("CameraScripting::SetupCurrent")]
        public static void SetupCurrent(Camera cur) => throw new NotImplementedException();
        //
        // Summary:
        //     Add a command buffer to be executed at a specified place.
        //
        // Parameters:
        //   evt:
        //     When to execute the command buffer during rendering.
        //
        //   buffer:
        //     The buffer to execute.
        public void AddCommandBuffer(UnityEngine.Rendering.CameraEvent evt, UnityEngine.Rendering.CommandBuffer buffer) => throw new NotImplementedException();
        //
        // Summary:
        //     Adds a command buffer to the GPU's async compute queues and executes that command
        //     buffer when graphics processing reaches a given point.
        //
        // Parameters:
        //   evt:
        //     The point during the graphics processing at which this command buffer should
        //     commence on the GPU.
        //
        //   buffer:
        //     The buffer to execute.
        //
        //   queueType:
        //     The desired async compute queue type to execute the buffer on.
        public void AddCommandBufferAsync(UnityEngine.Rendering.CameraEvent evt, UnityEngine.Rendering.CommandBuffer buffer, UnityEngine.Rendering.ComputeQueueType queueType) => throw new NotImplementedException();
        public void CalculateFrustumCorners(UnityEngine.Rect viewport, float z, UnityEngine.Camera.MonoOrStereoscopicEye eye, UnityEngine.Vector3[] outCorners) => throw new NotImplementedException();
        //
        // Summary:
        //     Calculates and returns oblique near-plane projection matrix.
        //
        // Parameters:
        //   clipPlane:
        //     Vector4 that describes a clip plane.
        //
        // Returns:
        //     Oblique near-plane projection matrix.
        //[FreeFunction("CameraScripting::CalculateObliqueMatrix", HasExplicitThis = true)]
        public UnityEngine.Matrix4x4 CalculateObliqueMatrix(UnityEngine.Vector4 clipPlane) => throw new NotImplementedException();
        //
        // Summary:
        //     Makes this camera's settings match other camera.
        //
        // Parameters:
        //   other:
        //     Copy camera settings to the other camera.
        //[FreeFunction("CameraScripting::CopyFrom", HasExplicitThis = true)]
        public void CopyFrom(Camera other) => throw new NotImplementedException();
        public void CopyStereoDeviceProjectionMatrixToNonJittered(UnityEngine.Camera.StereoscopicEye eye) => throw new NotImplementedException();

        //
        // Summary:
        //     Get command buffers to be executed at a specified place.
        //
        // Parameters:
        //   evt:
        //     When to execute the command buffer during rendering.
        //
        // Returns:
        //     Array of command buffers.
        //[FreeFunction("CameraScripting::GetCommandBuffers", HasExplicitThis = true)]
        public UnityEngine.Rendering.CommandBuffer[] GetCommandBuffers(UnityEngine.Rendering.CameraEvent evt) => throw new NotImplementedException();
            
        public UnityEngine.Matrix4x4 GetStereoNonJitteredProjectionMatrix(UnityEngine.Camera.StereoscopicEye eye) => throw new NotImplementedException();
       
        public UnityEngine.Matrix4x4 GetStereoProjectionMatrix(UnityEngine.Camera.StereoscopicEye eye) => throw new NotImplementedException();
      
        public UnityEngine.Matrix4x4 GetStereoViewMatrix(UnityEngine.Camera.StereoscopicEye eye) => throw new NotImplementedException();
        //
        // Summary:
        //     Remove all command buffers set on this camera.
        public void RemoveAllCommandBuffers() => throw new NotImplementedException();
        //
        // Summary:
        //     Remove command buffer from execution at a specified place.
        //
        // Parameters:
        //   evt:
        //     When to execute the command buffer during rendering.
        //
        //   buffer:
        //     The buffer to execute.
        public void RemoveCommandBuffer(UnityEngine.Rendering.CameraEvent evt, UnityEngine.Rendering.CommandBuffer buffer) => throw new NotImplementedException();
        //
        // Summary:
        //     Remove command buffers from execution at a specified place.
        //
        // Parameters:
        //   evt:
        //     When to execute the command buffer during rendering.
        public void RemoveCommandBuffers(UnityEngine.Rendering.CameraEvent evt) => throw new NotImplementedException();
        //
        // Summary:
        //     Render the camera manually.
        //[FreeFunction("CameraScripting::Render", HasExplicitThis = true)]
        public void Render() => throw new NotImplementedException();
        //[FreeFunction("CameraScripting::RenderDontRestore", HasExplicitThis = true)]
        public void RenderDontRestore() => throw new NotImplementedException();
        public bool RenderToCubemap(UnityEngine.Cubemap cubemap) => throw new NotImplementedException();
        //
        // Summary:
        //     Render into a cubemap from this camera.
        //
        // Parameters:
        //   faceMask:
        //     A bitfield indicating which cubemap faces should be rendered into.
        //
        //   cubemap:
        //     The texture to render to.
        //
        // Returns:
        //     False if rendering fails, else true.
        public bool RenderToCubemap(UnityEngine.RenderTexture cubemap, int faceMask) => throw new NotImplementedException();
        public bool RenderToCubemap(UnityEngine.RenderTexture cubemap) => throw new NotImplementedException();
        //
        // Summary:
        //     Render into a static cubemap from this camera.
        //
        // Parameters:
        //   cubemap:
        //     The cube map to render to.
        //
        //   faceMask:
        //     A bitmask which determines which of the six faces are rendered to.
        //
        // Returns:
        //     False if rendering fails, else true.
        public bool RenderToCubemap(UnityEngine.Cubemap cubemap, int faceMask) => throw new NotImplementedException();
        public bool RenderToCubemap(UnityEngine.RenderTexture cubemap, int faceMask, UnityEngine.Camera.MonoOrStereoscopicEye stereoEye) => throw new NotImplementedException();
        //
        // Summary:
        //     Render the camera with shader replacement.
        //
        // Parameters:
        //   shader:
        //
        //   replacementTag:
        //[FreeFunction("CameraScripting::RenderWithShader", HasExplicitThis = true)]
        public void RenderWithShader(UnityEngine.Shader shader, string replacementTag) => throw new NotImplementedException();
        //
        // Summary:
        //     Revert all camera parameters to default.
        public void Reset() => throw new NotImplementedException();
        //
        // Summary:
        //     Revert the aspect ratio to the screen's aspect ratio.
        public void ResetAspect() => throw new NotImplementedException();
        //
        // Summary:
        //     Make culling queries reflect the camera's built in parameters.
        public void ResetCullingMatrix() => throw new NotImplementedException();

        //
        // Summary:
        //     Make the projection reflect normal camera's parameters.
        public void ResetProjectionMatrix() => throw new NotImplementedException();
        //
        // Summary:
        //     Remove shader replacement from camera.
        public void ResetReplacementShader() => throw new NotImplementedException();
        //
        // Summary:
        //     Reset the camera to using the Unity computed projection matrices for all stereoscopic
        //     eyes.
        public void ResetStereoProjectionMatrices() => throw new NotImplementedException();
        //
        // Summary:
        //     Reset the camera to using the Unity computed view matrices for all stereoscopic
        //     eyes.
        public void ResetStereoViewMatrices() => throw new NotImplementedException();
        //
        // Summary:
        //     Resets this Camera's transparency sort settings to the default. Default transparency
        //     settings are taken from GraphicsSettings instead of directly from this Camera.
        public void ResetTransparencySortSettings() => throw new NotImplementedException();
        //
        // Summary:
        //     Make the rendering position reflect the camera's position in the Scene.
        public void ResetWorldToCameraMatrix() => throw new NotImplementedException();
        //
        // Summary:
        //     Returns a ray going from camera through a screen point.
        //
        // Parameters:
        //   eye:
        //     Optional argument that can be used to specify which eye transform to use. Default
        //     is Mono.
        //
        //   pos:
        public UnityEngine.Ray ScreenPointToRay(UnityEngine.Vector3 pos) => throw new NotImplementedException();
        public UnityEngine.Ray ScreenPointToRay(UnityEngine.Vector3 pos, UnityEngine.Camera.MonoOrStereoscopicEye eye) => throw new NotImplementedException();
        //
        // Summary:
        //     Transforms position from screen space into viewport space.
        //
        // Parameters:
        //   position:
        public UnityEngine.Vector3 ScreenToViewportPoint(UnityEngine.Vector3 position) => throw new NotImplementedException();
        public UnityEngine.Vector3 ScreenToWorldPoint(UnityEngine.Vector3 position, UnityEngine.Camera.MonoOrStereoscopicEye eye) => throw new NotImplementedException();
        //
        // Summary:
        //     Transforms position from screen space into world space.
        //
        // Parameters:
        //   position:
        public UnityEngine.Vector3 ScreenToWorldPoint(UnityEngine.Vector3 position) => throw new NotImplementedException();
        //
        // Summary:
        //     Make the camera render with shader replacement.
        //
        // Parameters:
        //   shader:
        //
        //   replacementTag:
        public void SetReplacementShader(UnityEngine.Shader shader, string replacementTag) => throw new NotImplementedException();

        public void SetStereoProjectionMatrix(UnityEngine.Camera.StereoscopicEye eye, UnityEngine.Matrix4x4 matrix) => throw new NotImplementedException();

        public void SetStereoViewMatrix(UnityEngine.Camera.StereoscopicEye eye, UnityEngine.Matrix4x4 matrix) => throw new NotImplementedException();
        //
        // Summary:
        //     Sets the Camera to render to the chosen buffers of one or more RenderTextures.
        //
        // Parameters:
        //   colorBuffer:
        //     The RenderBuffer(s) to which UnityEngine.Color information will be rendered.
        //
        //   depthBuffer:
        //     The RenderBuffer to which depth information will be rendered.
        public void SetTargetBuffers(UnityEngine.RenderBuffer colorBuffer, UnityEngine.RenderBuffer depthBuffer) => throw new NotImplementedException();
        //
        // Summary:
        //     Sets the Camera to render to the chosen buffers of one or more RenderTextures.
        //
        // Parameters:
        //   colorBuffer:
        //     The RenderBuffer(s) to which UnityEngine.Color information will be rendered.
        //
        //   depthBuffer:
        //     The RenderBuffer to which depth information will be rendered.
        public void SetTargetBuffers(UnityEngine.RenderBuffer[] colorBuffer, UnityEngine.RenderBuffer depthBuffer) => throw new NotImplementedException();
        //
        // Summary:
        //     Returns a ray going from camera through a viewport point.
        //
        // Parameters:
        //   eye:
        //     Optional argument that can be used to specify which eye transform to use. Default
        //     is Mono.
        //
        //   pos:
        public UnityEngine.Ray ViewportPointToRay(UnityEngine.Vector3 pos) => throw new NotImplementedException();
        public UnityEngine.Ray ViewportPointToRay(UnityEngine.Vector3 pos, UnityEngine.Camera.MonoOrStereoscopicEye eye) => throw new NotImplementedException();
        //
        // Summary:
        //     Transforms position from viewport space into screen space.
        //
        // Parameters:
        //   position:
        public UnityEngine.Vector3 ViewportToScreenPoint(UnityEngine.Vector3 position) => throw new NotImplementedException();
        public UnityEngine.Vector3 ViewportToWorldPoint(UnityEngine.Vector3 position, UnityEngine.Camera.MonoOrStereoscopicEye eye) => throw new NotImplementedException();
        //
        // Summary:
        //     Transforms position from viewport space into world space.
        //
        // Parameters:
        //   position:
        //     The 3d vector in Viewport space.
        //
        // Returns:
        //     The 3d vector in World space.
        public UnityEngine.Vector3 ViewportToWorldPoint(UnityEngine.Vector3 position) => throw new NotImplementedException();
        //
        // Summary:
        //     Transforms position from world space into screen space.
        //
        // Parameters:
        //   eye:
        //     Optional argument that can be used to specify which eye transform to use. Default
        //     is Mono.
        //
        //   position:
        public UnityEngine.Vector3 WorldToScreenPoint(UnityEngine.Vector3 position) => throw new NotImplementedException();
        public UnityEngine.Vector3 WorldToScreenPoint(UnityEngine.Vector3 position, UnityEngine.Camera.MonoOrStereoscopicEye eye) => throw new NotImplementedException();
        public UnityEngine.Vector3 WorldToViewportPoint(UnityEngine.Vector3 position, UnityEngine.Camera.MonoOrStereoscopicEye eye) => throw new NotImplementedException();
        //
        // Summary:
        //     Transforms position from world space into viewport space.
        //
        // Parameters:
        //   eye:
        //     Optional argument that can be used to specify which eye transform to use. Default
        //     is Mono.
        //
        //   position:
        public UnityEngine.Vector3 WorldToViewportPoint(UnityEngine.Vector3 position) => throw new NotImplementedException();
    }
}