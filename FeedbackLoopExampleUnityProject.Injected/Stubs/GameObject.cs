using System;
using System.Collections.Generic;

/// <summary>
/// This file is provided so that unity engine classes can be swapped out
/// during running in a reloadable context, enabling runninf of game code
/// outside of the unity engine. The classes are generated by using the
/// 'Go to Definition' in VS, and copying out the definition into this file.
/// All methods and getters and then set to return <see cref="NotImplementedException"/>,
/// and only methods used by the scenario are made to work (such as Input,
/// and Scene Traversal mechanisms)
/// </summary>
namespace FL
{
    /// <summary>
    /// Replacement Class for <see cref="UnityEngine.GameObject" />
    /// </summary>
    public partial class GameObject : FL.Object
    {
        //
        // Summary:
        //     The layer the game object is in.
        public int layer { get; set; }
        //
        // Summary:
        //     The local active state of this GameObject. (Read Only)
        public bool activeSelf => throw new NotImplementedException();
        //
        // Summary:
        //     Defines whether the GameObject is active in the Scene.
        public bool activeInHierarchy => throw new NotImplementedException();
        //
        // Summary:
        //     Editor only API that specifies if a game object is static.
        public bool isStatic { get; set; }
        //
        // Summary:
        //     The tag of this game object.
        public string tag { get; set; }
        //
        // Summary:
        //     Scene that the GameObject is part of.
        public UnityEngine.SceneManagement.Scene scene => throw new NotImplementedException();


        //
        // Summary:
        //     Creates a game object with a primitive mesh renderer and appropriate collider.
        //
        // Parameters:
        //   type:
        //     The type of primitive object to create.
        //[FreeFunction("GameObjectBindings::CreatePrimitive")]
        public static GameObject CreatePrimitive(UnityEngine.PrimitiveType type) => throw new NotImplementedException();
        //
        // Summary:
        //     Finds a GameObject by name and returns it.
        //
        // Parameters:
        //   name:
        //[FreeFunction(Name = "GameObjectBindings::Find")]
        public static GameObject Find(string name) => throw new NotImplementedException();
        //
        // Summary:
        //     Returns a list of active GameObjects tagged tag. Returns empty array if no GameObject
        //     was found.
        //
        // Parameters:
        //   tag:
        //     The name of the tag to search GameObjects for.
        //[FreeFunction(Name = "GameObjectBindings::FindGameObjectsWithTag", ThrowsException = true)]
        public static GameObject[] FindGameObjectsWithTag(string tag) => throw new NotImplementedException();
        //[FreeFunction(Name = "GameObjectBindings::FindGameObjectWithTag", ThrowsException = true)]
        public static GameObject FindGameObjectWithTag(string tag) => throw new NotImplementedException();
        //
        // Summary:
        //     Returns one active GameObject tagged tag. Returns null if no GameObject was found.
        //
        // Parameters:
        //   tag:
        //     The tag to search for.
        public static GameObject FindWithTag(string tag) => throw new NotImplementedException();
        //
        // Summary:
        //     Adds a component class of type componentType to the game object. C# Users can
        //     use a generic version.
        //
        // Parameters:
        //   componentType:
        //[TypeInferenceRule(TypeInferenceRules.TypeReferencedByFirstArgument)]
        public Component AddComponent(Type componentType) => throw new NotImplementedException();
        //
        // Summary:
        //     Adds a component class named className to the game object.
        //
        // Parameters:
        //   className:
        //[EditorBrowsable(EditorBrowsableState.Never)]
        //[Obsolete("GameObject.AddComponent with string argument has been deprecated. Use GameObject.AddComponent<T>() instead. (UnityUpgradable).", true)]
        public Component AddComponent(string className) => throw new NotImplementedException();
        //
        // Summary:
        //     Calls the method named methodName on every MonoBehaviour in this game object
        //     or any of its children.
        //
        // Parameters:
        //   methodName:
        //
        //   parameter:
        //
        //   options:
        //[FreeFunction(Name = "Scripting::BroadcastScriptingMessage", HasExplicitThis = true)]
        public void BroadcastMessage(string methodName, object parameter, UnityEngine.SendMessageOptions options) => throw new NotImplementedException();
        //
        // Summary:
        //     Calls the method named methodName on every MonoBehaviour in this game object
        //     or any of its children.
        //
        // Parameters:
        //   methodName:
        //
        //   parameter:
        //
        //   options:
        //[ExcludeFromDocs]
        public void BroadcastMessage(string methodName, object parameter) => throw new NotImplementedException();
        //
        // Parameters:
        //   methodName:
        //
        //   options:
        public void BroadcastMessage(string methodName, UnityEngine.SendMessageOptions options) => throw new NotImplementedException();
        //
        // Summary:
        //     Is this game object tagged with tag ?
        //
        // Parameters:
        //   tag:
        //     The tag to compare.
        //[FreeFunction(Name = "GameObjectBindings::CompareTag", HasExplicitThis = true)]
        public bool CompareTag(string tag) => throw new NotImplementedException();
        //
        // Summary:
        //     Returns the component with name type if the game object has one attached, null
        //     if it doesn't.
        //
        // Parameters:
        //   type:
        //     The type of Component to retrieve.
        public Component GetComponent(string type) => throw new NotImplementedException();
        //
        // Summary:
        //     Returns the component of Type type if the game object has one attached, null
        //     if it doesn't.
        //
        // Parameters:
        //   type:
        //     The type of Component to retrieve.
        //[FreeFunction(Name = "GameObjectBindings::GetComponentFromType", HasExplicitThis = true, ThrowsException = true)]
        //[TypeInferenceRule(TypeInferenceRules.TypeReferencedByFirstArgument)]
        public Component GetComponent(Type type) => throw new NotImplementedException();
        //
        // Summary:
        //     Returns the component of Type type in the GameObject or any of its children using
        //     depth first search.
        //
        // Parameters:
        //   type:
        //     The type of Component to retrieve.
        //
        //   includeInactive:
        //
        // Returns:
        //     A component of the matching type, if found.
        //[FreeFunction(Name = "GameObjectBindings::GetComponentInChildren", HasExplicitThis = true, ThrowsException = true)]
        //[TypeInferenceRule(TypeInferenceRules.TypeReferencedByFirstArgument)]
        public Component GetComponentInChildren(Type type, bool includeInactive) => throw new NotImplementedException();
        //
        // Summary:
        //     Returns the component of Type type in the GameObject or any of its children using
        //     depth first search.
        //
        // Parameters:
        //   type:
        //     The type of Component to retrieve.
        //
        //   includeInactive:
        //
        // Returns:
        //     A component of the matching type, if found.
        //[TypeInferenceRule(TypeInferenceRules.TypeReferencedByFirstArgument)]
        public Component GetComponentInChildren(Type type) => throw new NotImplementedException();
        //[ExcludeFromDocs]
        public T GetComponentInChildren<T>() => throw new NotImplementedException();
        public T GetComponentInChildren<T>(bool includeInactive) => throw new NotImplementedException();
        //
        // Summary:
        //     Returns the component of Type type in the GameObject or any of its parents.
        //
        // Parameters:
        //   type:
        //     Type of component to find.
        //[FreeFunction(Name = "GameObjectBindings::GetComponentInParent", HasExplicitThis = true, ThrowsException = true)]
        //[TypeInferenceRule(TypeInferenceRules.TypeReferencedByFirstArgument)]
        public Component GetComponentInParent(Type type) => throw new NotImplementedException();
        public T GetComponentInParent<T>() => throw new NotImplementedException();
        public void GetComponents<T>(List<T> results) => throw new NotImplementedException();
        public T[] GetComponents<T>() => throw new NotImplementedException();
        //
        // Summary:
        //     Returns all components of Type type in the GameObject.
        //
        // Parameters:
        //   type:
        //     The type of Component to retrieve.
        public Component[] GetComponents(Type type) => throw new NotImplementedException();
        public void GetComponents(Type type, List<Component> results) => throw new NotImplementedException();
        //
        // Summary:
        //     Returns all components of Type type in the GameObject or any of its children.
        //
        // Parameters:
        //   type:
        //     The type of Component to retrieve.
        //
        //   includeInactive:
        //     Should Components on inactive GameObjects be included in the found set?
        //[ExcludeFromDocs]
        public Component[] GetComponentsInChildren(Type type) => throw new NotImplementedException();
        //
        // Summary:
        //     Returns all components of Type type in the GameObject or any of its children.
        //
        // Parameters:
        //   type:
        //     The type of Component to retrieve.
        //
        //   includeInactive:
        //     Should Components on inactive GameObjects be included in the found set?
        public Component[] GetComponentsInChildren(Type type, bool includeInactive) => throw new NotImplementedException();
        public void GetComponentsInChildren<T>(bool includeInactive, List<T> results) => throw new NotImplementedException();
        public void GetComponentsInChildren<T>(List<T> results) => throw new NotImplementedException();
        public T[] GetComponentsInChildren<T>() => throw new NotImplementedException();
        public T[] GetComponentsInChildren<T>(bool includeInactive) => throw new NotImplementedException();
        //[ExcludeFromDocs]
        public Component[] GetComponentsInParent(Type type) => throw new NotImplementedException();
        public void GetComponentsInParent<T>(bool includeInactive, List<T> results) => throw new NotImplementedException();
        public T[] GetComponentsInParent<T>() => throw new NotImplementedException();
        //
        // Summary:
        //     Returns all components of Type type in the GameObject or any of its parents.
        //
        // Parameters:
        //   type:
        //     The type of Component to retrieve.
        //
        //   includeInactive:
        //     Should inactive Components be included in the found set?
        public Component[] GetComponentsInParent(Type type, bool includeInactive) => throw new NotImplementedException();
        public T[] GetComponentsInParent<T>(bool includeInactive) => throw new NotImplementedException();
        //[EditorBrowsable(EditorBrowsableState.Never)]
        //[Obsolete("gameObject.PlayAnimation is not supported anymore. Use animation.Play()", true)]
        public void PlayAnimation(Object animation) => throw new NotImplementedException();
        //[EditorBrowsable(EditorBrowsableState.Never)]
        //[Obsolete("GameObject.SampleAnimation(AnimationClip, float) has been deprecated. Use AnimationClip.SampleAnimation(GameObject, float) instead (UnityUpgradable).", true)]
        public void SampleAnimation(Object clip, float time) => throw new NotImplementedException();
        //
        // Parameters:
        //   methodName:
        //
        //   options:
        public void SendMessage(string methodName, UnityEngine.SendMessageOptions options) => throw new NotImplementedException();

        //
        // Summary:
        //     Calls the method named methodName on every MonoBehaviour in this game object.
        //
        // Parameters:
        //   methodName:
        //     The name of the method to call.
        //
        //   value:
        //     An optional parameter value to pass to the called method.
        //
        //   options:
        //     Should an error be raised if the method doesn't exist on the target object?
        //[ExcludeFromDocs]
        public void SendMessage(string methodName, object value) => throw new NotImplementedException();
        //
        // Summary:
        //     Calls the method named methodName on every MonoBehaviour in this game object.
        //
        // Parameters:
        //   methodName:
        //     The name of the method to call.
        //
        //   value:
        //     An optional parameter value to pass to the called method.
        //
        //   options:
        //     Should an error be raised if the method doesn't exist on the target object?
        //[FreeFunction(Name = "Scripting::SendScriptingMessage", HasExplicitThis = true)]
        public void SendMessage(string methodName, object value, UnityEngine.SendMessageOptions options) => throw new NotImplementedException();
        //
        // Parameters:
        //   methodName:
        //
        //   options:
        public void SendMessageUpwards(string methodName, UnityEngine.SendMessageOptions options) => throw new NotImplementedException();
        //
        // Summary:
        //     Calls the method named methodName on every MonoBehaviour in this game object
        //     and on every ancestor of the behaviour.
        //
        // Parameters:
        //   methodName:
        //     The name of the method to call.
        //
        //   value:
        //     An optional parameter value to pass to the called method.
        //
        //   options:
        //     Should an error be raised if the method doesn't exist on the target object?
        //[ExcludeFromDocs]
        public void SendMessageUpwards(string methodName) => throw new NotImplementedException();
        //
        // Summary:
        //     Calls the method named methodName on every MonoBehaviour in this game object
        //     and on every ancestor of the behaviour.
        //
        // Parameters:
        //   methodName:
        //     The name of the method to call.
        //
        //   value:
        //     An optional parameter value to pass to the called method.
        //
        //   options:
        //     Should an error be raised if the method doesn't exist on the target object?
        //[ExcludeFromDocs]
        public void SendMessageUpwards(string methodName, object value) => throw new NotImplementedException();
        //
        // Summary:
        //     Calls the method named methodName on every MonoBehaviour in this game object
        //     and on every ancestor of the behaviour.
        //
        // Parameters:
        //   methodName:
        //     The name of the method to call.
        //
        //   value:
        //     An optional parameter value to pass to the called method.
        //
        //   options:
        //     Should an error be raised if the method doesn't exist on the target object?
        //[FreeFunction(Name = "Scripting::SendScriptingMessageUpwards", HasExplicitThis = true)]
        public void SendMessageUpwards(string methodName, object value, UnityEngine.SendMessageOptions options) => throw new NotImplementedException();
        //
        // Summary:
        //     ActivatesDeactivates the GameObject, depending on the given true or false/ value.
        //
        // Parameters:
        //   value:
        //     Activate or deactivate the object, where true activates the GameObject and false
        //     deactivates the GameObject.
        //[NativeMethod(Name = "SetSelfActive")]
        public void SetActive(bool value) => throw new NotImplementedException();
        //[NativeMethod(Name = "SetActiveRecursivelyDeprecated")]
        //[Obsolete("gameObject.SetActiveRecursively() is obsolete. Use GameObject.SetActive(), which is now inherited by children.")]
        public void SetActiveRecursively(bool state) => throw new NotImplementedException();
        //[EditorBrowsable(EditorBrowsableState.Never)]
        //[Obsolete("gameObject.StopAnimation is not supported anymore. Use animation.Stop()", true)]
        public void StopAnimation() => throw new NotImplementedException();
    }
}