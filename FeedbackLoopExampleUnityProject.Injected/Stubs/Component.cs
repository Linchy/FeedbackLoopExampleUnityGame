using System;
using System.Collections.Generic;

/// <summary>
/// This file is provided so that unity engine classes can be swapped out
/// during running in a reloadable context, enabling runninf of game code
/// outside of the unity engine. The classes are generated by using the
/// 'Go to Definition' in VS, and copying out the definition into this file.
/// All methods and getters and then set to return <see cref="NotImplementedException"/>,
/// and only methods used by the scenario are made to work (such as Input,
/// and Scene Traversal mechanisms)
/// </summary>
namespace FL
{
    /// <summary>
    /// Replacement Class for <see cref="UnityEngine.Component" />
    /// </summary>
    public partial class Component : Object
    {
        //
        // Summary:
        //     The tag of this game object.
        public string tag { get; set; }
        //
        // Summary:
        //     The Transform attached to this GameObject.
        public Transform transform => throw new NotImplementedException();
        //
        // Summary:
        //     Calls the method named methodName on every MonoBehaviour in this game object
        //     or any of its children.
        //
        // Parameters:
        //   methodName:
        //     Name of the method to call.
        //
        //   parameter:
        //     Optional parameter to pass to the method (can be any value).
        //
        //   options:
        //     Should an error be raised if the method does not exist for a given target object?
        //[ExcludeFromDocs]
        public void BroadcastMessage(string methodName) => throw new NotImplementedException();
        //
        // Summary:
        //     Calls the method named methodName on every MonoBehaviour in this game object
        //     or any of its children.
        //
        // Parameters:
        //   methodName:
        //     Name of the method to call.
        //
        //   parameter:
        //     Optional parameter to pass to the method (can be any value).
        //
        //   options:
        //     Should an error be raised if the method does not exist for a given target object?
        //[ExcludeFromDocs]
        public void BroadcastMessage(string methodName, object parameter) => throw new NotImplementedException();
        //
        // Summary:
        //     Calls the method named methodName on every MonoBehaviour in this game object
        //     or any of its children.
        //
        // Parameters:
        //   methodName:
        //     Name of the method to call.
        //
        //   parameter:
        //     Optional parameter to pass to the method (can be any value).
        //
        //   options:
        //     Should an error be raised if the method does not exist for a given target object?
        //[FreeFunction("BroadcastMessage", HasExplicitThis = true)]
        public void BroadcastMessage(string methodName, object parameter, UnityEngine.SendMessageOptions options) => throw new NotImplementedException();
        //
        // Summary:
        //     Calls the method named methodName on every MonoBehaviour in this game object
        //     or any of its children.
        //
        // Parameters:
        //   methodName:
        //     Name of the method to call.
        //
        //   parameter:
        //     Optional parameter to pass to the method (can be any value).
        //
        //   options:
        //     Should an error be raised if the method does not exist for a given target object?
        public void BroadcastMessage(string methodName, UnityEngine.SendMessageOptions options) => throw new NotImplementedException();
        //
        // Summary:
        //     Is this game object tagged with tag ?
        //
        // Parameters:
        //   tag:
        //     The tag to compare.
        public bool CompareTag(string tag) => throw new NotImplementedException();
        //
        // Summary:
        //     Returns the component of Type type if the game object has one attached, null
        //     if it doesn't.
        //
        // Parameters:
        //   type:
        //     The type of Component to retrieve.
        //[TypeInferenceRule(TypeInferenceRules.TypeReferencedByFirstArgument)]
        public Component GetComponent(Type type) => throw new NotImplementedException();

        //
        // Summary:
        //     Returns the component with name type if the game object has one attached, null
        //     if it doesn't.
        //
        // Parameters:
        //   type:
        //[FreeFunction(HasExplicitThis = true)]
        public Component GetComponent(string type) => throw new NotImplementedException();
        //[ExcludeFromDocs]
        public T GetComponentInChildren<T>() => throw new NotImplementedException();
        public T GetComponentInChildren<T>(bool includeInactive) => throw new NotImplementedException();
        //[TypeInferenceRule(TypeInferenceRules.TypeReferencedByFirstArgument)]
        public Component GetComponentInChildren(Type t, bool includeInactive) => throw new NotImplementedException();
        //
        // Summary:
        //     Returns the component of Type type in the GameObject or any of its children using
        //     depth first search.
        //
        // Parameters:
        //   t:
        //     The type of Component to retrieve.
        //
        // Returns:
        //     A component of the matching type, if found.
        //[TypeInferenceRule(TypeInferenceRules.TypeReferencedByFirstArgument)]
        public Component GetComponentInChildren(Type t) => throw new NotImplementedException();
        //
        // Summary:
        //     Returns the component of Type type in the GameObject or any of its parents.
        //
        // Parameters:
        //   t:
        //     The type of Component to retrieve.
        //
        // Returns:
        //     A component of the matching type, if found.
        //[TypeInferenceRule(TypeInferenceRules.TypeReferencedByFirstArgument)]
        public Component GetComponentInParent(Type t) => throw new NotImplementedException();
        public T GetComponentInParent<T>() => throw new NotImplementedException();
        public T[] GetComponents<T>() => throw new NotImplementedException();
        public void GetComponents<T>(List<T> results) => throw new NotImplementedException();
        public void GetComponents(Type type, List<Component> results) => throw new NotImplementedException();
        //
        // Summary:
        //     Returns all components of Type type in the GameObject.
        //
        // Parameters:
        //   type:
        //     The type of Component to retrieve.
        public Component[] GetComponents(Type type) => throw new NotImplementedException();
        public void GetComponentsInChildren<T>(List<T> results) => throw new NotImplementedException();
        public void GetComponentsInChildren<T>(bool includeInactive, List<T> result) => throw new NotImplementedException();
        //[ExcludeFromDocs]
        public Component[] GetComponentsInChildren(Type t) => throw new NotImplementedException();
        //
        // Summary:
        //     Returns all components of Type type in the GameObject or any of its children.
        //
        // Parameters:
        //   t:
        //     The type of Component to retrieve.
        //
        //   includeInactive:
        //     Should Components on inactive GameObjects be included in the found set? includeInactive
        //     decides which children of the GameObject will be searched. The GameObject that
        //     you call GetComponentsInChildren on is always searched regardless.
        public Component[] GetComponentsInChildren(Type t, bool includeInactive) => throw new NotImplementedException();
        public T[] GetComponentsInChildren<T>() => throw new NotImplementedException();
        public T[] GetComponentsInChildren<T>(bool includeInactive) => throw new NotImplementedException();
        public T[] GetComponentsInParent<T>() => throw new NotImplementedException();
        //[ExcludeFromDocs]
        public Component[] GetComponentsInParent(Type t) => throw new NotImplementedException();
        public void GetComponentsInParent<T>(bool includeInactive, List<T> results) => throw new NotImplementedException();
        public T[] GetComponentsInParent<T>(bool includeInactive) => throw new NotImplementedException();
        //
        // Summary:
        //     Returns all components of Type type in the GameObject or any of its parents.
        //
        // Parameters:
        //   t:
        //     The type of Component to retrieve.
        //
        //   includeInactive:
        //     Should inactive Components be included in the found set?
        public Component[] GetComponentsInParent(Type t, bool includeInactive) => throw new NotImplementedException();
        //
        // Summary:
        //     Calls the method named methodName on every MonoBehaviour in this game object.
        //
        // Parameters:
        //   methodName:
        //     Name of the method to call.
        //
        //   value:
        //     Optional parameter for the method.
        //
        //   options:
        //     Should an error be raised if the target object doesn't implement the method for
        //     the message?
        public void SendMessage(string methodName, UnityEngine.SendMessageOptions options) => throw new NotImplementedException();
        //
        // Summary:
        //     Calls the method named methodName on every MonoBehaviour in this game object.
        //
        // Parameters:
        //   methodName:
        //     Name of the method to call.
        //
        //   value:
        //     Optional parameter for the method.
        //
        //   options:
        //     Should an error be raised if the target object doesn't implement the method for
        //     the message?
        //[FreeFunction("SendMessage", HasExplicitThis = true)]
        public void SendMessage(string methodName, object value, UnityEngine.SendMessageOptions options) => throw new NotImplementedException();
        //
        // Summary:
        //     Calls the method named methodName on every MonoBehaviour in this game object.
        //
        // Parameters:
        //   methodName:
        //     Name of the method to call.
        //
        //   value:
        //     Optional parameter for the method.
        //
        //   options:
        //     Should an error be raised if the target object doesn't implement the method for
        //     the message?
        public void SendMessage(string methodName) => throw new NotImplementedException();
        //
        // Summary:
        //     Calls the method named methodName on every MonoBehaviour in this game object.
        //
        // Parameters:
        //   methodName:
        //     Name of the method to call.
        //
        //   value:
        //     Optional parameter for the method.
        //
        //   options:
        //     Should an error be raised if the target object doesn't implement the method for
        //     the message?
        public void SendMessage(string methodName, object value) => throw new NotImplementedException();
        //
        // Summary:
        //     Calls the method named methodName on every MonoBehaviour in this game object
        //     and on every ancestor of the behaviour.
        //
        // Parameters:
        //   methodName:
        //     Name of method to call.
        //
        //   value:
        //     Optional parameter value for the method.
        //
        //   options:
        //     Should an error be raised if the method does not exist on the target object?
        public void SendMessageUpwards(string methodName, UnityEngine.SendMessageOptions options) => throw new NotImplementedException();
        //
        // Summary:
        //     Calls the method named methodName on every MonoBehaviour in this game object
        //     and on every ancestor of the behaviour.
        //
        // Parameters:
        //   methodName:
        //     Name of method to call.
        //
        //   value:
        //     Optional parameter value for the method.
        //
        //   options:
        //     Should an error be raised if the method does not exist on the target object?
        //[ExcludeFromDocs]
        public void SendMessageUpwards(string methodName, object value) => throw new NotImplementedException();
        //
        // Summary:
        //     Calls the method named methodName on every MonoBehaviour in this game object
        //     and on every ancestor of the behaviour.
        //
        // Parameters:
        //   methodName:
        //     Name of method to call.
        //
        //   value:
        //     Optional parameter value for the method.
        //
        //   options:
        //     Should an error be raised if the method does not exist on the target object?
        //[FreeFunction(HasExplicitThis = true)]
        public void SendMessageUpwards(string methodName, object value, UnityEngine.SendMessageOptions options) => throw new NotImplementedException();
        //
        // Summary:
        //     Calls the method named methodName on every MonoBehaviour in this game object
        //     and on every ancestor of the behaviour.
        //
        // Parameters:
        //   methodName:
        //     Name of method to call.
        //
        //   value:
        //     Optional parameter value for the method.
        //
        //   options:
        //     Should an error be raised if the method does not exist on the target object?
        //[ExcludeFromDocs]
        public void SendMessageUpwards(string methodName) => throw new NotImplementedException();
    }
}