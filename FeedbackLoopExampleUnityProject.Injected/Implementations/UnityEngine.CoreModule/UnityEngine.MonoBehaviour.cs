using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;

/// <summary>
/// This file is provided so that unity engine classes can be swapped out
/// during running in a reloadable context, enabling runninf of game code
/// outside of the unity engine. The classes are generated by using the
/// 'Go to Definition' in VS, and copying out the definition into this file.
/// All methods and getters and then set to return <see cref="NotImplementedException"/>,
/// and only methods used by the scenario are made to work (such as Input,
/// and Scene Traversal mechanisms)
/// </summary>
namespace FL_UnityEngine
{
    /// <summary>
    /// Replacement Class for <see cref="UnityEngine.MonoBehaviour" />
    /// </summary>
    public partial class MonoBehaviour
    {
        private readonly Dictionary<string, MethodInfo> _methodsByName;

        public MonoBehaviour()
        {
            this._methodsByName = new Dictionary<string, MethodInfo>();

            var methods = this.GetType().GetMethods(BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic);
            foreach (var method in methods)
            {
                _methodsByName[method.Name] = method;
            }
        }

        //
        // Summary:
        //     Invokes the method methodName in time seconds.
        //
        // Parameters:
        //   methodName:
        //
        //   time:
        public void Invoke(string methodName, float time)
        {
            if (time != 0)
            {
                throw new NotImplementedException();
            }

            if (_methodsByName.TryGetValue(methodName, out var method))
            {
                method.Invoke(this, null);
            }
        }
    }

    public enum MonoBehaviourAction
    {
        Awake = 0,
        Start,

        Update,
        FixedUpdate,
    }
}